#summary blogチュートリアル(2) データベースの設定
#sidebar TableOfBlogTutorial

== MySQLにblogbearデータベースを作成¶ ==

次に、ブログで使用するデータベースをセットアップしましょう。今は、投稿記事を保存するためのテーブルをひとつ作成します。テスト用にいくつかの記事も入れておきましょう。次のSQLをデータベースで実行してください。

== blogbearデーターベースを作成 ==
{{{
CREATE DATABASE `blogbear` DEFAULT CHARACTER SET 'utf8';
}}}

== postsテーブルを作成 ==
{{{
CREATE TABLE posts (
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
title VARCHAR(50),
body TEXT,
created DATETIME DEFAULT NULL,
modified DATETIME DEFAULT NULL
);
/* それから、テスト用に記事をいくつか入れておきます。 */
INSERT INTO posts (title,body,created)
VALUES ('タイトル', 'これは、記事の本文です。', NOW());
INSERT INTO posts (title,body,created)
VALUES ('またタイトル', 'そこに本文が続きます。', NOW());
INSERT INTO posts (title,body,created)
VALUES ('タイトルの逆襲', 'こりゃ本当に面白そう！うそ。', NOW());
}}}

== データベースの利用 ==

現在のBEAR.Sundayに既定のデータベースはなく、設定ファイルもありません。

アプリケーションリソースがデータベースを利用できるようにする方法はいくつかありますが、ここでは@Dbアノテーションを利用したDBオブジェクト利用をとりあげます。

まずアプリケーションモジュールの`configure`メソッドの中で以下のようにコーディングしてデータベースを利用するクラスにDBオブジェクトを渡せるように設定をします。

{{{
$this->bind()->annotatedWith('master_db')->toInstance(['driver' => 'pdo_mysql', 'host' => 'localhost', 'dbname' => 'blogbear', 'user' => 'root', 'password' => null, 'charset' => 'UTF8']);
$this->bind()->annotatedWith('slave_db')->toInstance(['driver' => 'pdo_mysql', 'host' => 'localhost', 'dbname' => 'blogbear', 'user' => 'root', 'password' => null, 'charset' => 'UTF8']);
$dbInjector = $this->requestInjection('\BEAR\Framework\Interceptor\DbInjector');
$this->bindInterceptor(
    $this->matcher->annotatedWith('BEAR\Framework\Annotation\Db'),
    $this->matcher->any(),
    [$dbInjector]
);
}}}

ここでメソッドにインターセプターをバインドしています。バインドされたメソッドは、メソッドの実行の前にDBオブジェクトがプロパティに代入されるようになります。（上記のバインドの条件は`@Dbアノテーション`をクラスに持つメソッドの"全て"です。）

    Note: インターセプターは本来呼ばれるメソッドに変わって特定の処理を本来のメソッドの前後に行います。インターセプターは問題をオブジェクトではなく、アスペクトに分割するためこれをアスペクト指向プログラミング(AOP)と呼びます。

一旦この設定が行われると、以下のようにクラスに*@Db* とアノテートされてる全てのクラスでセッター経由でDBオブジェクトがセットされます。またDBオブジェクトもリクエストメソッドに応じてmaster/slaveが区別されます。

{{{
/**
 * @Db
 */
class Posts
{
    /**
     * DB
     *
     * @var Connection
     */
    private $db;

    /**
     * Set DB
     *
     * @param Connection $db
     *
     * @return void
     */
    public function setDb(Connection $db)
    {
        $this->db = $db;
    }
}}}

このようにBEAR.Sundayでは原則としてアプリケーションは自ら外部インスタンスの取得を行いません。new キーワードを用いたインスタンス生成や、ファクトリー、サービスコンテナからの取得など、メソッド内でのインスタンス取得の直接要求を行わず外部から代入される事を期待します。

依存性の解決 (Dependency resolution)を行う`インジェクター`がアプリケーションに変わって必要インスタンスを生成・取得し、そのインスタンスを外部から代入します。

この時、外部からのインスタンスを依存（Dependency)または依存オブジェクト、その代入を注入（インジェクション）、また提供されるインスタンスのうち主に機能を提供するものをサービス（オブジェクト）と呼びます。依存性の注入（Dependency Injection = DI)パターンと呼ばれるデザインパターンです。

もし、依存性の注入やアスペクト指向プログラミングに馴染みがなくともここで理解する必要はありません。とりあえあずここでは「@DbとアノテートされたクラスにDBオブジェクトが渡される仕組みの設定を行った」と理解していれば充分です。

== テーブルスキーマの設定 ==

今回の例ではORMを使用していないのでありません。