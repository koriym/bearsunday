#summary blogチュートリアル(2) データベースの設定
#sidebar TableOfBlogTutorial

== MySQLにblogbearデータベースを作成¶ ==

次に、ブログで使用するデータベースをセットアップしましょう。今は、投稿記事を保存するためのテーブルをひとつ作成します。テスト用にいくつかの記事も入れておきましょう。次のSQLをデータベースで実行してください。

== blogbearデーターベースを作成 ==
{{{
CREATE DATABASE `blogbear` DEFAULT CHARACTER SET 'utf8';
}}}

== postsテーブルを作成 ==
{{{
CREATE TABLE posts (
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
title VARCHAR(50),
body TEXT,
created DATETIME DEFAULT NULL,
modified DATETIME DEFAULT NULL
);
/* それから、テスト用に記事をいくつか入れておきます。 */
INSERT INTO posts (title,body,created)
VALUES ('タイトル', 'これは、記事の本文です。', NOW());
INSERT INTO posts (title,body,created)
VALUES ('またタイトル', 'そこに本文が続きます。', NOW());
INSERT INTO posts (title,body,created)
VALUES ('タイトルの逆襲', 'こりゃ本当に面白そう！うそ。', NOW());
}}}

== データベースの利用 ==

現在のBEAR.Sundayに既定のデータベースはなく、設定ファイルもありません。

代わりにデータベースを利用するクラスに、必要なインスタンスを渡すための*バインディング*をアプリケーションモジュールの中でコーディングします。

利用コードでは@Injectアノテーションを使ってそのオブジェクトを受け取ります。

{{{
/**
 * @Inject
 */
public function __construct(Connection $connection)
}}}

コンストラクタでなく通常のメソッドにも@Injectとアノテートできます。

{{{
/**
 * @Inject
 */
public function setDb(Connection $connection)
}}}

    Note: メソッド名は自由です。＠Injectとアノテートされたメソッドに必要なオブジェクトが代入されます。

    Note: 一旦モジュールで設定が行われると、BEAR.Sundayで作成されるどのクラスの中でもこのようにデータベースオブジェクトが受け取れます。

モジュールでは`Connection`インターフェイスと実際のデータベースオブジェクトのインスタンスをバインドします。

_`apps/sandbox/Modules/AppModule.php`_

{{{
class AppModule extends AbstractModule
{
    protected function configure()
    {
        $this->bind('Doctrine\DBAL\Connection')
        ->toProvider('\sandbox\Module\Provider\DbalProvider')
        ->in(Scope::SINGLETON);
    }
}
}}}

`Doctrine\DBAL\Connection`インターフェイスと`\sandbox\Module\Provider\DbalProvider`プロバイダークラスで生成されるインスタンスを*バインド*しています。

`DbalProvider`プロバイダーではインスタンスを提供する`Provide`インターフェイスを実装します。

_`apps/sandbox/Modules/Provider/DbalProvider.php`_
{{{
class DbalProvider implements Provide
{
    public function __construct()
    {
        $this->dsn = 'mysql://username:password@host/database_name';

    public function get()
    {
        $config = new \Doctrine\DBAL\Configuration();
        //..
        $connectionParams = [
            'driver' => 'pdo_sqlite',
            'path' => $this->dsn,
        	'user' => null,
            'password' => null
        ];
        $conn = \Doctrine\DBAL\DriverManager::getConnection($connectionParams, $config);
        return $conn;
    }
}}}

@InjectとアノテートされたメソッドにBEAR.Sundayがどのインスタンスを渡せばいいか設定されました。利用するクラスはどこでも@Injectと`Connection`インターフェイスを使ってデータベースオブジェクトが利用できるようになりました。

このようにBEAR.Sundayでは必要なインスタンスは基本的にすべて外部からインジェクトされます。

通常、アプリケーションは自ら外部インスタンスの取得を行いません。new キーワードを用いたインスタンス生成や、ファクトリーの直接利用、サービスコンテナからの取得など、メソッド内でのインスタンス取得の直接要求を行いません。

依存性の解決 (Dependency resolution)を行う`インジェクター`がアプリケーションに変わって必要インスタンスを生成・取得し、そのインスタンスを外部から代入します。

この時、外部からのインスタンスを依存（Dependency)または依存オブジェクト、その代入を注入（インジェクション）、また提供されるインスタンスのうち主に機能を提供するものをサービス（オブジェクト）と呼びます。依存性の注入（Dependency Injection = DI)パターンと呼ばれるデザインパターンです。


== テーブルスキーマの設定 ==

今回の例ではORMを使用していないのでありません。