#summary blogチュートリアル(4) 閲覧ページの作成
#sidebar TableOfBlogTutorial

== ページの作成 ==

BEAR.Sundayで新しくページを作成する場合、通常次の２つを作成します。

 * ページリソースクラス
 * ページリソーステンプレート

ページリソースもappリソースと同じ構成、インターフェイスを持ちます。appリソースが標準の状態では何も持たず必要なDBオブジェクトをDIでインジェクトしたように、ページリソースもページ用の特別なオブジェクトはデフォルトでは何も持たず、依存をインジェクトして使用します。

== ページコントローラー ==

MVCのコントローラにあたる部分はBEARではページリソースです。ページはwebのリクエストを受け取り、アプリケーションリソースをリクエストして、自らを構成します。またページはそのまま出力用のオブジェクトとしても扱われます。

 Note: BEAR.Sundayではルーターも利用できますが、このブログアプリでは利用しません。

 Note: BEAR.Sundayではサイトの１ページが１ページリソースクラスに相当し：[http://capsctrl.que.jp/kdmsnr/wiki/PofEAA/?PageController ページコントローラー]の働きをします。

== ページクラス ==

ページもアプリケーションリソースと同じようにリソースの一つです。この記事表示ページの役割はアプリケーションAPIの記事リソースをGETリクエストで取得してページのpostsスロットに格納することです。

[appリソース app_resource]のセクションではコンソールからappリソースリクエストを行いましたがPHPでリソースリクエストを行うにはリソースリクエストクライアントを使います。リソースリクエストクライントはtraitでインジェクトされます。

traitを使用するuse文でこのように記述するとリソースクライアントが$resourceプロパティにインジェクトされます。
{{{
    use ResourceInject;
}}}

インジェクトされたリソースクライアントを使ってリソースリクエストを行うにはこのようにします。
{{{
$this->resource->get->uri('app://self/posts')->request()
}}}

まとめるとこうなります。

{{{
<?php
namespace sandbox\Resource\Page\Blog;

use BEAR\Framework\Resource\AbstractPage as Page;
use BEAR\Framework\Inject\ResourceInject;
use BEAR\Framework\Annotation\Cache;

class Posts extends Page
{
    use ResourceInject;
	
    public $body = [
        'posts' => ''
    ];

    /**
     * Get
     *
     * @Cache
     */
    public function onGet()
    {
        $this['posts'] = $this->resource->get->uri('app://self/posts')->request();
        return $this;
    }
}

}}}
`app://self/posts`リソースへのリクエストを自らのpostsというスロットに格納しています。

    Note: $this['posts'] は $this->body['body']の省略した書き方のシンタックスシュガー(=読み書きのしやすさのために導入される構文)です。

 Note:MVCのコントローラーと違って、出力用のテンプレートや出力用オブジェクト等に関心が払われてないのに注目してみてください。


== リソースとしてのページ ==

それではページリソースをアプリケーションリソースと同じようにコンソールでアクセスしてみましょう。

{{{
$ php api.php get page://self/blog/posts

200 OK
[BODY]
posts:*get app://self/posts*
}}}
（実際には太字ではなくアンダーラインです)

postsというスロットに*get app://self/posts* というリクエストが格納されていることを表しています。

ページリソースはMVCのコントローラーの役割をするとともに出力用のオブジェクトの役割も果たしています。しかしどのように表現されるかにはまだ関心が払われていません。

== リソースキャッシュ ==

ページリソースには`@Cache`とアノテートされていてsandboxアプリケーションではこのアノテーションを持つメソッドにはキャシュインターセプターがバインドされています。例えば30秒間リソースをキャッシュしたいならこのように表記します。

{{{
@Cache(30)
}}}

== 無期限キャッシュ ==

このページリソースには時間が指定されていないので、リソースのGETリクエストは無期限にキャッシュされonGetメソッドが実行されるのは最初の一回のみです。これでは記事が追加されたり削除されてもこの記事表示ページは変更されないのでしょうか？

この記事表示ページリソースの役割は、記事リソースをリクエストしてpostsにセットすることです。その役割はリクエストによらず不変でこの役割がキャッシュされます。

ページリソースにセットしているのはリクエストの結果ではなくて、リクエストそのものです。@Cacheで無期限のキャッシュを指定してもキャッシュされた記事リソースリクエストは毎回実行され、記事リソースのリソース状態は反映されます。 (この場合、@Cacheでセーブされるのは`OnGet()`メソッド内でリクエストを作るわずかなコストだけです)