#summary アプリケーション
= 導入 =

BEAR.Sundayではbootstrapでアプリケーションオブジェクトが生成されます。
オブジェクトを生成するためにはまずその依存が必要です。しかしその依存もまた依存が必要で、そのまた..と続き最終的にアプリケーションオブジェクトがオブジェクトグラフ（オブジェクト間の関係性）として取得されます。

こうしてアプリケーションオブジェクトはアプリケーションの実行に必要な全てのオブジェクトが含まれたオブジェクトになります。

== コンパイルとランタイム　==

モジュールはオブジェクトの抽象（インターフェイスや抽象クラス）と実装（実クラスやファクトリー）の束縛、それにメソッドとその横断的振る舞い（アスペクト）の束縛の集合です。アプリケーションはモードによってそのモジュールが選択され、その構成知識でアプリケーションオブジェクトが生成されます。

BEAR.Sundayは「依存性の注入パターン」に基づいていて、アプリケーションオブジェクトはそのコンストラクション（コンパイルタイム）と実行（ランタイム）にはっきりとした区別があります。オブジェクトはConstructionを行うオブジェクトと、Executionを行うオブジェクトにはっきりと区別され混ざりません。

 * boot時にモードに応じたアプリケーションオブジェクトが生成されます。（コンパイルタイム）
 * その後はオブジェクトのexecution（実行）が始まります（ランタイム）
 * executionの時に新しいオブジェクトを取得するときには`Provider`を使います。それ以外の方法ではオブジェクトの取得を原則行いません。

== コンストラクションの再利用 ==

モジュールに基づいて一度コンパイルされた（依存が早期束縛された）アプリケーションオブジェクトグラフの生成はリクエストをまたいで再利用されます。できあがったばかりのアプリケーションオブジェクトはすぐAPCコンテナに格納され次回以降のリクエストで再利用されます。

つまり、BEAR.Sundayで利用するオブジェクトのコンストラクタ`__construct`は（キャッシュを利用したプロダクションモードでは）サービスを開始してオブジェクトのコンパイルに一度だけしか実行されません。二度目からはオブジェクトのコンストラクションが行われないためです。

== sandboxアプリケーションでの依存 ==

アプリケーションはアプリケーションスクリプトから始まります。webの公開領域、あるいはコンソールで最初に呼ばれるゲートウエイファイルです。

HelloWorldアプリ、中でも最も最少構成の`min.php`を見て見ましょう。

{{{
$app = require dirname(__DIR__) . '/scripts/instance.php';
$response = $app->resource->get->uri('page://self/minhello')->eager->request();

echo $response->body;
exit(0);
}}}

アプリケーションオブジェクトはスクリプトによって取得されそのオブジェクトが持つリソースクライアントを使って特定リソースをアクセスして、その結果を`echo`しています。

  Note: `header`出力を可能にして、少しだけ高機能にした[https://github.com/koriym/BEAR.Package/blob/master/apps/Helloworld/public/basic.php Helloworld/public/basic.php]もご覧ください。

== アプリケーションスクリプト ==
{{{
/** @global $mode */

// Application instance
$mode = "Prod";
$app = require dirname(__DIR__) . '/scripts/instance.php';

// Route
$router = new Router; // page controller only.

// Dispatch
$globals = $GLOBALS;
list($method, $pagePath, $query) = $router->match($globals);

// Request
try {
    $page = $app->resource->$method->uri('page://self/' . $pagePath)->withQuery($query)->eager->request();
} catch (\Exception $e) {
    $page = $app->exceptionHandler->handle($e);
}

// Transfer
$app->response->setResource($page)->render()->prepare()->send();
exit(0);
}}}

このアプリケーションスクリプトはアプリケーションがどのようなフローで実行されるかを表しています。

アプリケーションオブジェクトの依存をどのように構成するかをモジュールが決定するように、アプリケーションの実行をどのように構成するかをアプリケーションスクリプトが表します。

アプリケーション要求に応じてこのスクリプトを編集します。例えば以下のような変更です。

 * ルーターを単純なページコントローラーのものから他のものに変更
 * 特定のURLのアクセスのIN/OUTを全て記録
 * 例外ハンドリングの変更
 * UAに応じたアプリケーションフローの変更

=== アプリケーションスクリプトはアプリケーションドメイン ===

アプリケーションの振る舞いを変更するにはこのアプリケーションスクリプトを直接編集します。フレームワークはアプリケーションのライフサイクルに関与しません。アプリケーションアーキテクトはアプリケーション要求にしたがって、このひな形を編集してアプリケーションのフロー（実行）を構成します。

== アプリケーションオブジェクト ==

アプリケーションオブジェクトの役割はアプリケーションスクリプトで利用するサービスを保持する事だけです。例えば上記スクリプトでは実行モードに応じた`resource`、`response`それに`exceptionHandler`が用意してあればそれで問題ありません。

理解の為に最小限にしたアプリケーションクラスを紹介します。

{{{
use BEAR\Sunday\Application\Context;

final class App implements Context
{
    public $resource;
    public $response;
    public $logger;

    /**
     * Constructor
     *
     * @param ResourceInterface $resource Resource client
     * @param ResponseInterface $response Web / Console response
     * @param ApplicationLogger $logger   Application logger
     *
     * @Inject
     */
    public function __construct(
        ResourceInterface $resource,
        ResponseInterface $response,
        ApplicationLogger $logger
    ) {
        $this->resource = $resource;
        $this->response = $response;
        $this->logger = $logger;
        $resource->attachParamProvider('Provides', new Provides);
    }
}
}}}

アプリケーションが必要とするサービスをコンストラクタで受け取ります。アプリケーションスクリプトはこれらのサービスを利用します。
モジュールはこれらのインターフェイスに何がバインドされるかを知っています。そのモジュールを使ってインスタンスをアプリケーションオブジェクトを生成します。

{{{
    $injector = Injector::create([new ProdModule]);
    $app = $injector->getInstance('BEAR\Sunday\Application\Context');
}}}

モジュールの中ではアプリケーションインターフェイス(Context)に対するアプリケーションクラスのバインドもされているので、`Context`インターフェイスを指定してアプリケーションを生成することができます。この取得コストはとても大きいのですが、instance.phpスクリプトではapc cacheを使ってアプリケーションの取得の再利用を行っています。

== 早期束縛 ==

アプリケーションの実行(ランタイム)に依存せず、リクエスト毎に変わらない依存の注入はこのコンパイルで完了しておくようにします。

モジュールを使ったコンフィギュレーションはオブジェクトがどのように構成（生成）されるかを決めるものであって、オブジェクトのランタイムでの実行を直接決めるものではありません。

例えばランタイムでコンフィギュレーションを見て振る舞いを変更する事は推奨されません。

{{{
// 非推奨
if ($config['debug'] === true) {
    // debug用の振る舞い
}
}}}


その代わりに *コンパイル時にコンフィギュレーションを見て振る舞いの違うオブジェクトを束縛* します。コンパイルが完了したオブジェクトは、ランタイムでの可変点のみの処理を行うようにします。つまり毎リクエスト同じ文字列をアサインするようなコードは非推奨です。

例えば開発画面で様々なオブジェクトの情報が確認できるツールが現れるのは、レンダラインターフェイスに開発用レンダラが束縛されているためで、レンダラがモードを確認してレンダリングを変えているのでありません。つまりアプリケーションの`mode`は実行時の振る舞いをランタイムで変えるための変数ではなくて、そのモードに応じたオブジェクトを生成するためのものです。`Sandbox`アプリケーションを構成するそれぞれのオブジェクトはモードに対して無知です。

この早期束縛と遅延束縛の明確な区別はソフトウエアの品質とパフォーマンスの寄与を目的としていて、アプリケーション構造の大きな前提です。