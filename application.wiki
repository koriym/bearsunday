#summary BEAR.Sundayアプリケーション
= 導入 =

BEAR.Sundayではbootstrapでアプリケーションオブジェクトが生成されます。アプリケーションオブジェクトはアプリケーションの実行に必要な全てのサービスを含んだオブジェクトです。原則的にBEAR.Sundayアプリケーションで利用する全てのオブジェクトはこのオブジェクトに含まれるか、含まれたファクトリーで生成されます。

このオブジェクトを生成するためにはまずその依存が必要です。しかしその依存もまた依存が必要で、そのまた..と続き最終的にアプリケーションオブジェクトがオブジェクトグラフ（オブジェクト間の関係性）として取得されます。

こうしてアプリケーションオブジェクトはアプリケーションの実行に必要な全てのオブジェクトが含まれたオブジェクトになります。

== コンパイルとランタイム　==

[module モジュール]はオブジェクトの抽象（インターフェイスや抽象クラス）と実装（実クラスやファクトリー）の束縛、それにメソッドとその横断的振る舞い（アスペクト）の束縛の集合です。アプリケーションはモードによってそのモジュールが選択され、その構成知識でアプリケーションオブジェクトが生成されます。

BEAR.Sundayは「依存性の注入パターン」に基づいていて、アプリケーションオブジェクトはそのコンストラクション（コンパイルタイム）と実行（ランタイム）にはっきりとした区別があります。オブジェクトはConstructionを行うオブジェクトと、Executionを行うオブジェクトにはっきりと区別され混ざりません。

 * boot時にモードに応じたアプリケーションオブジェクトが生成されます。（コンパイルタイム）
 * その後はオブジェクトのexecution（実行）が始まります（ランタイム）
 * executionの時に新しいオブジェクトを取得するときには`Provider`を使います。それ以外の方法ではオブジェクトの取得を原則行いません。

== コンストラクションの再利用 ==

モジュールに基づいて一度コンパイルされた（依存が早期束縛された）アプリケーションオブジェクトグラフの生成はリクエストをまたいで再利用されます。できあがったばかりのアプリケーションオブジェクトはすぐAPCコンテナに格納され次回以降のリクエストで再利用されます。

つまり、BEAR.Sundayで利用するオブジェクトのコンストラクタ`__construct`は（キャッシュを利用したプロダクションモードでは）サービスを開始してオブジェクトのコンパイルに一度だけしか実行されません。二度目からはオブジェクトのコンストラクションが行われないためです。

== 早期束縛 ==

アプリケーションの実行(ランタイム)に依存せず、リクエスト毎に変わらない依存の注入はこのコンパイルで完了しておくようにします。

モジュールを使ったコンフィギュレーションはオブジェクトがどのように構成（生成）されるかを決めるものであって、オブジェクトのランタイムでの実行を直接決めるものではありません。

例えばランタイムでコンフィギュレーションを見て振る舞いを変更する事は推奨されません。

{{{
// 非推奨
if ($config['debug'] === true) {
    // debug用の振る舞い
}
}}}


その代わりに *コンパイル時にコンフィギュレーションを見て振る舞いの違うオブジェクトを束縛* します。コンパイルが完了したオブジェクトは、ランタイムでの可変点のみの処理を行うようにします。つまり毎リクエスト同じ文字列をアサインするようなコードは非推奨です。

例えば開発画面で様々なオブジェクトの情報が確認できるツールが現れるのは、レンダラインターフェイスに開発用レンダラが束縛されているためで、レンダラがモードを確認してレンダリングを変えているのでありません。つまりアプリケーションの`mode`は実行時の振る舞いをランタイムで変えるための変数ではなくて、そのモードに応じたオブジェクトを生成するためのものです。`Sandbox`アプリケーションを構成するそれぞれのオブジェクトはモードに対して無知です。

この早期束縛と遅延束縛の明確な区別はソフトウエアの品質とパフォーマンスの寄与を目的としていて、アプリケーション構造の大きな前提です。