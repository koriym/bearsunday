#summary モジュール
= 導入 =

モジュールはオブジェクトの抽象（インターフェイスや抽象クラス）と実装（実クラスやファクトリー）の束縛、それにメソッドとその横断的振る舞い（アスペクト）の束縛の集合（DIとAOPの設定）です。DIの設定ではインターフェイスに対してクラスを束縛（バインド）します。AOPは特定のメソッドに対してインターセプターを束縛します。

モジュールはこの束縛の集合によってオブジェクトがどのように組み立てられるかを決定し、インジェクターはそのモジュールを利用してオブジェクトの生成を行います。

例えば`APIモジュール`では出力インターフェイスにJSON出力のクラスが束縛されているので出力がJSONになります。出力オブジェクトがモードに応じて振る舞いを変えているのでは*ない事*に注目してください。モードに応じて振る舞いを帰るのではなく、モードに応じてオブジェクトの構成を変更しています。

  Note: 変更に対して開いていて、修正に対して閉じている[http://d.hatena.ne.jp/asakichy/20090126/1232979830 オブジェクトの開放閉鎖原則(OCP)]に従っています。

== バインドDSL ==

モジュールは`AbstractModule`を継承し、`configure`メソッド内ではバインドDSLをDSLを使い@Injectでアノテートされたインジェクションポイントにどのようにインスタンス提供するかをバインドします。 


== バインドの種類 ==

`AbstractModule`を継承したモジュールの`configure`メソッド内で、`@Inject`でアノテートされたインジェクションポイントにどのようにインスタンス提供をするかをバインドします。インスタンスの提供は様々な方法があり、引き数なしのクラス名を指定する`Linked Binding`、名前を使ってバインドする`"Named" Binding`、プロバイダーといわれる専用のファクトリーを使ってバインドする`Provider Bindings`等があります。

= Bindigns =

== Linked Binding ==

インターフェイス名と実クラス名をバインディングします。

{{{
$this->bind('TransactionLog')->to('DatabaseTransactionLog');
}}}

最も単純で一般的な方法です。引数を渡す事は出来ない事に注意してください。これは以下のように`@Inject`で指定された`TransactionLog`インターフェイスに`new DatabaseTransactionLog();`で生成したインスタンスをインジェクトします

_コンシュマー（インジェクトされる側）_
{{{
/**
 * @Inject
 */
public function setLog(TransactionLog $log)
}}}

== "Named" Binding ==

バインドに名前をつけます。

{{{
 $this->bind('CreditCardProcessor')->annotatedWith('Checkout')->to('CheckoutCreditCardProcessor');
}}}
_コンシュマー_

{{{
/**
 * @Inject
 * @Named("serceret_key")
 */
public function setProcessor(CreditCardProcessor $processor)
}}}

インターフェイスがないscalar型へのバインディングには必須です。

{{{
 $this->bind()->annotatedWith('secret_key')->toInstance(1234);
}}}

_コンシュマー_
{{{
/**
 * @Inject
 * @Named("serceret_key")
 */
public function setKey($stringKey)
}}}

== Instance Bindings ==

インスタンス（実体）をバインドします。これはnewキーワードで作成されたクラスのインスタンスに限りません。数値や文字列も含みます。インスタンスバインディングは他のバインディグ方法が利用可能なら、なるべく避けるべきバインディングです。他のバインディングと違って実際に使用されないインスタンスも作成されてしまいます。

{{{
$this->bind()->annotatedWith("login_timeout_seconds")->toInstance(10);
}}}

== Provider Bindings ==

オブジェクトのコンストラクションに引数が必要なものや、オブジェクトのコンストラクションが複雑なものはプロバイダーというファクトリークラスをバインドします。プロバイダーは`provider`インターフェイスを実装したgetメソッドがインスタンスを返します。

{{{  
$this->bind('TransactionLog')->toProvider('DatabaseTransactionLogProvider');

}}}

※TransactionLogインターフェイスはDatabaseTransactionLogProvidergetプロバイダーにバインドされます。このインジェクトが行われるタイミングでgetメソッドがコールされインスタンスが取得されます。


== Constructor Bindings ==
コンストラクターバインディングは、3rd partyのクラス（BEAR.Sunday、そのアプリケーション以外）、つまり`@Inject`でインジェクションポイントがマークされてないクラスのインジェクションを行うためのバインディングです。

コンストラクターの変数名をインジェクションポイントとして指定してバインドします。

{{{
$this->bind('TransactionLog')->toConstructor(['db' => new Database]);
}}}

== Scope ==

オブジェクトを*Singleton* として指定するために２つの方法があります。１つはクラスにアノテーションで指定する方法、もう一つはバインドの時に指定する方法です。

{{{
/**
 * @Scope(Scope::SINGLETON)
 */
public class InMemoryTransactionLog implements TransactionLog
{
}
}}}

{{{
$this->bind('TransactionLog')->to('InMemoryTransactionLog')->in(Scope::Singleton);
}}}

== Ray.DI ==

DIはRay.Diというパッケージで提供され、このページはGoogle Guiceを訳した別サイトのマニュアル [http://code.google.com/p/rayphp/wiki/Bindings Ray.Di] の抜粋です。