#summary はじめてのアスペクト

== 挨拶に現在時間を追加する ==

挨拶リソースに現在時刻を追加します。出来上がりイメージはこうです。

{{{
"Hello, BEAR. It is 10:22."
}}}

簡単ですね。このようにメッセージの後ろに時間を追加すればいいだけです。

{{{
    public function onGet($name = 'anonymous')
    {
        $time = date('g:i');
        return "{$this->message}, {$name}". " It is {$time} now";
    }
}}}

ではこの現在時刻の追加を他の10のリソースでも行いたいとしたらどうでしょう？「何かのメッセージの後に時間情報を追加」という処理を他の１０のリソースでも行います。

コピー＆ペーストが楽なのはその時だけです。では関数化しましょうか。

{{{
    public function onGet($name = 'anonymous')
    {
        return "{$this->message}, {$name}". timeMessage();
    }
}}}

集約され、再利用性が高まりました。
あるいはtraitを使ってみましょうか。

{{{
    use TimeMessageTrait;

    public function onGet($name = 'anonymous')
    {
        return "{$this->message}, {$name}". $this->getTimeMessage();
    }
}}}

同じですね。

しかしこの「後ろに時間をつける」という処理を外部に集約して取得することはできるようになりましたが、利用メソッドの数だけ変更が必要です。

今度は時間ではなくて、挨拶の後は天気情報を付加するように変更がありました。`timeMessage`を`weatherMessage`に変えましょうか？

それとも、後ろにメッセージが付加される事を汎用的に`postMessage`としましょうか。...だんだん苦しくなってきました。

== アスペクトにする ==

このようなメソッドを横断する処理はそもそもコーディングが難しい面があります。ログやキャッシュ、トランザクションなど何かの処理の前後に行うようなコードはあちこちに同じものがちらばったりした経験はないでしょうか？

begin, [query], (commit | rollback) という処理は[query]が変わるだけなのにいつも同じように全てを記述したりしなかったでしょうか。

ではこの横断的な処理を、元の本質的な処理と合成するようにしてみてはどうでしょうか。元のメッセージと付加するメッセージを動的に結合するのです。

この例では、「時刻情報を追加する」という処理をクラスをまたがって使われる（＝横断的な）処理とみなし、アスペクトと呼びます。このアスペクトと元の処理を合成するのがアスペクト指向プログラミングです。

== リフレクティブ・メソッドインボケーション・インターセプター ==

この横断的な処理と本質的な処理を合成するのにいくつかのデザインパターンがありますが、BEAR.Sundayではインターセプターというパターンを使います。

元のメソッド